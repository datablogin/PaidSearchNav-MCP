"""ROI analysis incorporating offline conversion data."""

import logging
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Tuple

from paidsearchnav.core.models.campaign import Campaign

from .base import CustomerJourney, Lead, LeadQuality, OfflineConversion
from .journey_tracking import AttributionModel, CustomerJourneyTracker

logger = logging.getLogger(__name__)


@dataclass
class ROIMetrics:
    """ROI metrics including offline conversions."""

    # Revenue metrics
    online_revenue: float = 0.0
    offline_revenue: float = 0.0
    total_revenue: float = 0.0

    # Conversion metrics
    online_conversions: int = 0
    offline_conversions: int = 0
    total_conversions: int = 0

    # Cost metrics
    ad_spend: float = 0.0
    cost_per_online_conversion: float = 0.0
    cost_per_offline_conversion: float = 0.0
    cost_per_conversion: float = 0.0

    # ROI metrics
    online_roi: float = 0.0
    offline_roi: float = 0.0
    total_roi: float = 0.0
    roas: float = 0.0  # Return on Ad Spend

    # Lead metrics
    total_leads: int = 0
    qualified_leads: int = 0
    lead_to_conversion_rate: float = 0.0
    cost_per_lead: float = 0.0
    cost_per_qualified_lead: float = 0.0

    # Customer lifetime value
    average_order_value: float = 0.0
    customer_lifetime_value: float = 0.0
    ltv_to_cac_ratio: float = 0.0  # LTV to Customer Acquisition Cost


@dataclass
class CampaignROI:
    """ROI metrics for a specific campaign."""

    campaign_id: str
    campaign_name: str
    metrics: ROIMetrics
    attribution_model: str
    date_range: Tuple[datetime, datetime]
    lead_quality_breakdown: Dict[str, int]  # Quality -> count
    conversion_lag_days: float = 0.0  # Average days from click to conversion


@dataclass
class ChannelROI:
    """ROI metrics by marketing channel."""

    channel: str
    metrics: ROIMetrics
    campaigns: List[CampaignROI]
    top_converting_keywords: List[Dict[str, Any]]
    attribution_credit: float = 0.0  # Percentage of total conversions


class ROIAnalyzer:
    """Analyzes ROI including offline conversion data."""

    def __init__(
        self,
        journey_tracker: CustomerJourneyTracker,
        attribution_model: AttributionModel = AttributionModel.LAST_CLICK,
    ):
        self.journey_tracker = journey_tracker
        self.attribution_model = attribution_model
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")

    def calculate_campaign_roi(
        self,
        campaign: Campaign,
        leads: List[Lead],
        journeys: List[CustomerJourney],
        offline_conversions: List[OfflineConversion],
        date_range: Tuple[datetime, datetime],
        customer_lifetime_value_multiplier: float = 1.0,
    ) -> CampaignROI:
        """Calculate ROI for a specific campaign.

        Args:
            campaign: Campaign object
            leads: Leads generated by the campaign
            journeys: Customer journeys involving the campaign
            offline_conversions: Offline conversions to attribute
            date_range: Date range for analysis
            customer_lifetime_value_multiplier: Multiplier for CLV calculation

        Returns:
            CampaignROI with detailed metrics
        """
        metrics = ROIMetrics()

        # Calculate ad spend
        metrics.ad_spend = self._calculate_campaign_spend(campaign, date_range)

        # Process leads
        lead_quality_breakdown = {"high": 0, "medium": 0, "low": 0, "unqualified": 0}
        qualified_lead_count = 0

        for lead in leads:
            metrics.total_leads += 1
            if lead.quality:
                lead_quality_breakdown[lead.quality.value] += 1
                if lead.quality in [LeadQuality.HIGH, LeadQuality.MEDIUM]:
                    qualified_lead_count += 1

        metrics.qualified_leads = qualified_lead_count

        # Calculate cost per lead
        if metrics.total_leads > 0:
            metrics.cost_per_lead = metrics.ad_spend / metrics.total_leads
        if metrics.qualified_leads > 0:
            metrics.cost_per_qualified_lead = metrics.ad_spend / metrics.qualified_leads

        # Process conversions from journeys with optimizations
        conversion_lag_times = []
        attributed_revenue = {"online": 0.0, "offline": 0.0}

        # Pre-filter journeys for this campaign to reduce iterations
        campaign_journeys = []
        for journey in journeys:
            # Quick check if campaign is in journey using any()
            if any(tp.get("campaign_id") == campaign.id for tp in journey.touchpoints):
                campaign_journeys.append(journey)

        # Process only relevant journeys
        for journey in campaign_journeys:
            # Get campaign touchpoints
            campaign_touchpoints = [
                tp for tp in journey.touchpoints if tp.get("campaign_id") == campaign.id
            ]

            # Calculate attribution once per journey
            attribution = self.journey_tracker.calculate_attribution(journey)

            # Get campaign's attribution share
            campaign_attribution = 0.0
            for channel, data in attribution.items():
                if data.get("campaign_id") == campaign.id:
                    campaign_attribution += data.get("credit", 0)

            # Skip if no attribution for this campaign
            if campaign_attribution == 0:
                continue

            # Process conversions with bulk operations
            for conversion in journey.conversions:
                attributed_value = conversion.conversion_value * campaign_attribution

                if conversion.conversion_name.startswith("offline_"):
                    metrics.offline_conversions += campaign_attribution
                    attributed_revenue["offline"] += attributed_value
                else:
                    metrics.online_conversions += campaign_attribution
                    attributed_revenue["online"] += attributed_value

                # Calculate conversion lag only if needed
                if campaign_touchpoints:
                    first_touch = datetime.fromisoformat(
                        campaign_touchpoints[0]["timestamp"]
                    )
                    lag_days = (conversion.conversion_time - first_touch).days
                    conversion_lag_times.append(lag_days)

        # Set revenue metrics
        metrics.online_revenue = attributed_revenue["online"]
        metrics.offline_revenue = attributed_revenue["offline"]
        metrics.total_revenue = metrics.online_revenue + metrics.offline_revenue

        # Round conversion counts
        metrics.online_conversions = round(metrics.online_conversions)
        metrics.offline_conversions = round(metrics.offline_conversions)
        metrics.total_conversions = (
            metrics.online_conversions + metrics.offline_conversions
        )

        # Calculate conversion rates and costs
        if metrics.total_leads > 0:
            metrics.lead_to_conversion_rate = (
                metrics.total_conversions / metrics.total_leads
            )

        if metrics.online_conversions > 0:
            metrics.cost_per_online_conversion = (
                metrics.ad_spend
                * (metrics.online_conversions / metrics.total_conversions)
            ) / metrics.online_conversions

        if metrics.offline_conversions > 0:
            metrics.cost_per_offline_conversion = (
                metrics.ad_spend
                * (metrics.offline_conversions / metrics.total_conversions)
            ) / metrics.offline_conversions

        if metrics.total_conversions > 0:
            metrics.cost_per_conversion = metrics.ad_spend / metrics.total_conversions
            metrics.average_order_value = (
                metrics.total_revenue / metrics.total_conversions
            )

        # Calculate ROI and ROAS
        if metrics.ad_spend > 0:
            metrics.online_roi = (
                (metrics.online_revenue - metrics.ad_spend) / metrics.ad_spend * 100
            )
            metrics.offline_roi = (
                (metrics.offline_revenue - metrics.ad_spend) / metrics.ad_spend * 100
            )
            metrics.total_roi = (
                (metrics.total_revenue - metrics.ad_spend) / metrics.ad_spend * 100
            )
            metrics.roas = metrics.total_revenue / metrics.ad_spend

        # Calculate customer lifetime value
        if metrics.average_order_value > 0:
            metrics.customer_lifetime_value = (
                metrics.average_order_value * customer_lifetime_value_multiplier
            )

        if metrics.cost_per_conversion > 0:
            metrics.ltv_to_cac_ratio = (
                metrics.customer_lifetime_value / metrics.cost_per_conversion
            )

        # Calculate average conversion lag
        avg_conversion_lag = (
            sum(conversion_lag_times) / len(conversion_lag_times)
            if conversion_lag_times
            else 0
        )

        return CampaignROI(
            campaign_id=campaign.id,
            campaign_name=campaign.name,
            metrics=metrics,
            attribution_model=self.attribution_model.value,
            date_range=date_range,
            lead_quality_breakdown=lead_quality_breakdown,
            conversion_lag_days=avg_conversion_lag,
        )

    def calculate_channel_roi(
        self,
        channel: str,
        campaigns: List[Campaign],
        all_leads: List[Lead],
        all_journeys: List[CustomerJourney],
        all_conversions: List[OfflineConversion],
        date_range: Tuple[datetime, datetime],
    ) -> ChannelROI:
        """Calculate ROI for a marketing channel.

        Args:
            channel: Channel name (e.g., "paid_search", "display")
            campaigns: Campaigns in this channel
            all_leads: All leads to analyze
            all_journeys: All customer journeys
            all_conversions: All offline conversions
            date_range: Date range for analysis

        Returns:
            ChannelROI with aggregated metrics
        """
        channel_metrics = ROIMetrics()
        campaign_rois = []
        keyword_performance = defaultdict(
            lambda: {
                "keyword": "",
                "leads": 0,
                "conversions": 0,
                "revenue": 0.0,
            }
        )

        # Create campaign ID set for faster lookups
        campaign_ids = {campaign.id for campaign in campaigns}

        # Pre-group leads by campaign for better performance
        leads_by_campaign = defaultdict(list)
        for lead in all_leads:
            if lead.campaign_id in campaign_ids:
                leads_by_campaign[lead.campaign_id].append(lead)

        # Pre-filter journeys by campaign presence
        journeys_by_campaign = defaultdict(list)
        for journey in all_journeys:
            # Check touchpoints for campaign IDs
            for tp in journey.touchpoints:
                campaign_id = tp.get("campaign_id")
                if campaign_id in campaign_ids:
                    journeys_by_campaign[campaign_id].append(journey)
                    break  # Only add journey once per campaign

        # Calculate ROI for each campaign
        for campaign in campaigns:
            # Use pre-grouped data
            campaign_leads = leads_by_campaign.get(campaign.id, [])
            campaign_journeys = journeys_by_campaign.get(campaign.id, [])

            # Calculate campaign ROI
            campaign_roi = self.calculate_campaign_roi(
                campaign=campaign,
                leads=campaign_leads,
                journeys=campaign_journeys,
                offline_conversions=all_conversions,
                date_range=date_range,
            )

            campaign_rois.append(campaign_roi)

            # Aggregate metrics
            self._aggregate_metrics(channel_metrics, campaign_roi.metrics)

            # Track keyword performance efficiently
            for lead in campaign_leads:
                if lead.keyword:
                    kw_data = keyword_performance[lead.keyword]
                    kw_data["keyword"] = lead.keyword
                    kw_data["leads"] += 1

        # Calculate top converting keywords
        top_keywords = sorted(
            keyword_performance.values(),
            key=lambda x: x["revenue"],
            reverse=True,
        )[:10]

        # Calculate channel's attribution credit
        total_attributed_conversions = sum(
            cr.metrics.total_conversions for cr in campaign_rois
        )
        if total_attributed_conversions > 0:
            attribution_credit = (
                channel_metrics.total_conversions / total_attributed_conversions * 100
            )
        else:
            attribution_credit = 0.0

        return ChannelROI(
            channel=channel,
            metrics=channel_metrics,
            campaigns=campaign_rois,
            top_converting_keywords=top_keywords,
            attribution_credit=attribution_credit,
        )

    def generate_roi_report(
        self,
        channels: List[ChannelROI],
        date_range: Tuple[datetime, datetime],
        include_predictions: bool = True,
    ) -> Dict[str, Any]:
        """Generate comprehensive ROI report.

        Args:
            channels: List of channel ROI data
            date_range: Date range for the report
            include_predictions: Whether to include ROI predictions

        Returns:
            Comprehensive ROI report
        """
        report = {
            "summary": {
                "date_range": {
                    "start": date_range[0].isoformat(),
                    "end": date_range[1].isoformat(),
                },
                "attribution_model": self.attribution_model.value,
                "generated_at": datetime.utcnow().isoformat(),
            },
            "overall_metrics": ROIMetrics(),
            "channel_breakdown": [],
            "insights": [],
            "recommendations": [],
        }

        # Aggregate overall metrics
        overall = report["overall_metrics"]
        for channel_roi in channels:
            self._aggregate_metrics(overall, channel_roi.metrics)

        # Add channel breakdown
        for channel_roi in channels:
            channel_data = {
                "channel": channel_roi.channel,
                "metrics": self._metrics_to_dict(channel_roi.metrics),
                "attribution_credit": channel_roi.attribution_credit,
                "top_keywords": channel_roi.top_converting_keywords[:5],
                "campaign_count": len(channel_roi.campaigns),
            }
            report["channel_breakdown"].append(channel_data)

        # Generate insights
        insights = self._generate_insights(channels, overall)
        report["insights"] = insights

        # Generate recommendations
        recommendations = self._generate_recommendations(channels, overall)
        report["recommendations"] = recommendations

        # Add predictions if requested
        if include_predictions:
            predictions = self._generate_roi_predictions(channels, overall)
            report["predictions"] = predictions

        # Convert overall metrics to dict
        report["overall_metrics"] = self._metrics_to_dict(overall)

        return report

    def _calculate_campaign_spend(
        self, campaign: Campaign, date_range: Tuple[datetime, datetime]
    ) -> float:
        """Calculate campaign spend for the date range."""
        # This would typically query the actual spend data
        # For now, return a calculated estimate based on campaign data
        days_in_range = (date_range[1] - date_range[0]).days
        daily_budget = getattr(campaign, "daily_budget", 100.0)
        return daily_budget * days_in_range

    def _aggregate_metrics(self, total: ROIMetrics, add: ROIMetrics):
        """Aggregate ROI metrics."""
        total.online_revenue += add.online_revenue
        total.offline_revenue += add.offline_revenue
        total.total_revenue += add.total_revenue

        total.online_conversions += add.online_conversions
        total.offline_conversions += add.offline_conversions
        total.total_conversions += add.total_conversions

        total.ad_spend += add.ad_spend
        total.total_leads += add.total_leads
        total.qualified_leads += add.qualified_leads

        # Recalculate derived metrics
        if total.ad_spend > 0:
            total.total_roi = (
                (total.total_revenue - total.ad_spend) / total.ad_spend * 100
            )
            total.roas = total.total_revenue / total.ad_spend

        if total.total_conversions > 0:
            total.cost_per_conversion = total.ad_spend / total.total_conversions
            total.average_order_value = total.total_revenue / total.total_conversions

        if total.total_leads > 0:
            total.cost_per_lead = total.ad_spend / total.total_leads
            total.lead_to_conversion_rate = total.total_conversions / total.total_leads

    def _metrics_to_dict(self, metrics: ROIMetrics) -> Dict[str, Any]:
        """Convert ROIMetrics to dictionary."""
        return {
            "revenue": {
                "online": round(metrics.online_revenue, 2),
                "offline": round(metrics.offline_revenue, 2),
                "total": round(metrics.total_revenue, 2),
            },
            "conversions": {
                "online": metrics.online_conversions,
                "offline": metrics.offline_conversions,
                "total": metrics.total_conversions,
            },
            "costs": {
                "ad_spend": round(metrics.ad_spend, 2),
                "cost_per_conversion": round(metrics.cost_per_conversion, 2),
                "cost_per_lead": round(metrics.cost_per_lead, 2),
                "cost_per_qualified_lead": round(metrics.cost_per_qualified_lead, 2),
            },
            "roi": {
                "total_roi_percentage": round(metrics.total_roi, 2),
                "roas": round(metrics.roas, 2),
                "ltv_to_cac_ratio": round(metrics.ltv_to_cac_ratio, 2),
            },
            "leads": {
                "total": metrics.total_leads,
                "qualified": metrics.qualified_leads,
                "conversion_rate": round(metrics.lead_to_conversion_rate * 100, 2),
            },
        }

    def _generate_insights(
        self, channels: List[ChannelROI], overall: ROIMetrics
    ) -> List[Dict[str, Any]]:
        """Generate insights from ROI data."""
        insights = []

        # Offline vs online revenue insight
        if overall.total_revenue > 0:
            offline_percentage = (overall.offline_revenue / overall.total_revenue) * 100
            insights.append(
                {
                    "type": "revenue_mix",
                    "title": "Offline Revenue Contribution",
                    "description": f"Offline conversions account for {offline_percentage:.1f}% of total revenue",
                    "impact": "high" if offline_percentage > 30 else "medium",
                }
            )

        # Best performing channel
        if channels:
            best_channel = max(channels, key=lambda x: x.metrics.total_roi)
            insights.append(
                {
                    "type": "top_channel",
                    "title": "Best Performing Channel",
                    "description": f"{best_channel.channel} has the highest ROI at {best_channel.metrics.total_roi:.1f}%",
                    "impact": "high",
                }
            )

        # Lead quality insight
        if overall.qualified_leads > 0 and overall.total_leads > 0:
            qual_rate = (overall.qualified_leads / overall.total_leads) * 100
            insights.append(
                {
                    "type": "lead_quality",
                    "title": "Lead Qualification Rate",
                    "description": f"{qual_rate:.1f}% of leads are qualified (high/medium quality)",
                    "impact": "medium" if qual_rate > 50 else "high",
                }
            )

        return insights

    def _generate_recommendations(
        self, channels: List[ChannelROI], overall: ROIMetrics
    ) -> List[Dict[str, str]]:
        """Generate recommendations based on ROI analysis."""
        recommendations = []

        # Budget reallocation recommendation
        if len(channels) > 1:
            sorted_channels = sorted(
                channels, key=lambda x: x.metrics.total_roi, reverse=True
            )
            if (
                sorted_channels[0].metrics.total_roi
                > sorted_channels[-1].metrics.total_roi * 2
            ):
                recommendations.append(
                    {
                        "type": "budget_reallocation",
                        "priority": "high",
                        "action": f"Consider reallocating budget from {sorted_channels[-1].channel} to {sorted_channels[0].channel}",
                        "expected_impact": "Increase overall ROI by 10-15%",
                    }
                )

        # Offline conversion optimization
        if overall.offline_conversions < overall.online_conversions * 0.1:
            recommendations.append(
                {
                    "type": "offline_tracking",
                    "priority": "medium",
                    "action": "Improve offline conversion tracking implementation",
                    "expected_impact": "Better visibility into true ROI",
                }
            )

        # Lead nurturing recommendation
        if overall.lead_to_conversion_rate < 0.02:  # Less than 2%
            recommendations.append(
                {
                    "type": "lead_nurturing",
                    "priority": "high",
                    "action": "Implement lead nurturing campaigns to improve conversion rate",
                    "expected_impact": "Increase conversion rate by 50-100%",
                }
            )

        return recommendations

    def _generate_roi_predictions(
        self, channels: List[ChannelROI], overall: ROIMetrics
    ) -> Dict[str, Any]:
        """Generate ROI predictions for the next period."""
        # Simple prediction model - in production, use ML models
        predictions = {
            "next_30_days": {
                "expected_revenue": overall.total_revenue * 1.05,  # 5% growth
                "expected_conversions": int(overall.total_conversions * 1.05),
                "confidence": 0.75,
            },
            "next_90_days": {
                "expected_revenue": overall.total_revenue * 3.2,  # Seasonal adjustment
                "expected_conversions": int(overall.total_conversions * 3.2),
                "confidence": 0.60,
            },
        }

        return predictions
