"""Geographic Optimization and Store-Level Performance Enhancement Scripts."""

import logging
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Set, Tuple

from paidsearchnav_mcp.platforms.google.client import GoogleAdsClient

from .base import ScriptBase, ScriptConfig, ScriptResult, ScriptStatus, ScriptType
from .local_intent_optimization import GeographicPerformanceMetric, StoreLocation

logger = logging.getLogger(__name__)


class GeographicActionType(Enum):
    """Types of geographic optimization actions."""

    BID_ADJUSTMENT = "bid_adjustment"
    LOCATION_EXCLUSION = "location_exclusion"
    RADIUS_OPTIMIZATION = "radius_optimization"
    DAYPART_ADJUSTMENT = "daypart_adjustment"
    DEMOGRAPHIC_TARGETING = "demographic_targeting"


class OptimizationPriority(Enum):
    """Priority levels for optimization actions."""

    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    CRITICAL = "critical"


@dataclass
class GeographicRecommendation:
    """Recommendation for geographic optimization."""

    action_type: GeographicActionType
    priority: OptimizationPriority
    location_identifier: str
    current_performance: GeographicPerformanceMetric
    recommended_change: Dict[str, Any]
    expected_impact: Dict[str, float]
    confidence_score: float
    reasoning: str


@dataclass
class StoreCompetitiveAnalysis:
    """Competitive analysis for a store location."""

    store_id: str
    market_share_estimate: float
    competitor_density: int
    local_search_volume: int
    seasonal_trends: Dict[str, float]
    opportunity_score: float
    threat_level: str


@dataclass
class RadiusPerformanceSegment:
    """Performance data for a specific radius segment."""

    radius_start: int
    radius_end: int
    impressions: int
    clicks: int
    conversions: int
    cost: float
    store_visits: int
    efficiency_score: float
    recommended_bid_adjustment: float


class GeographicOptimizationEngine(ScriptBase):
    """Engine for geographic targeting and store-level performance optimization."""

    def __init__(self, client: GoogleAdsClient, config: ScriptConfig):
        super().__init__(client, config)
        self.store_locations: List[StoreLocation] = []
        self.excluded_locations: Set[str] = set()
        self.competitor_data: Dict[str, Any] = {}

    def generate_script(self) -> str:
        """Generate Google Ads Script for geographic optimization."""
        store_data_js = self._generate_store_data_js()
        optimization_config_js = self._generate_optimization_config_js()

        return f"""
/**
 * Geographic Optimization and Store-Level Performance Enhancement
 * Generated by PaidSearchNav Issue #468
 */

{store_data_js}

{optimization_config_js}

function main() {{
  console.log('ðŸ—ºï¸ Starting Geographic Optimization and Store-Level Performance Enhancement');
  console.log('=' * 100);

  try {{
    const results = {{
      radiusOptimizations: [],
      bidAdjustments: [],
      locationExclusions: [],
      storePerformanceAnalysis: [],
      competitiveInsights: [],
      seasonalAdjustments: [],
      crossLocationAnalysis: [],
      timestamp: new Date().toISOString(),
    }};

    // Analyze radius performance for each store
    console.log('ðŸ“Š Analyzing radius performance by store...');
    results.radiusOptimizations = analyzeRadiusPerformance();

    // Generate geographic bid adjustments
    console.log('ðŸ’° Generating geographic bid adjustments...');
    results.bidAdjustments = generateGeographicBidAdjustments();

    // Identify underperforming locations for exclusion
    console.log('ðŸš« Identifying locations for exclusion...');
    results.locationExclusions = identifyLocationExclusions();

    // Comprehensive store performance analysis
    console.log('ðŸª Analyzing store-level performance...');
    results.storePerformanceAnalysis = analyzeStorePerformance();

    // Competitive analysis and market insights
    console.log('ðŸŽ¯ Generating competitive insights...');
    results.competitiveInsights = analyzeCompetitiveLandscape();

    // Seasonal and temporal optimizations
    console.log('ðŸ“… Analyzing seasonal performance patterns...');
    results.seasonalAdjustments = analyzeSeasonalPatterns();

    // Cross-location coordination
    console.log('ðŸ”„ Analyzing cross-location coordination...');
    results.crossLocationAnalysis = analyzeCrossLocationCoordination();

    // Generate comprehensive optimization report
    const optimizationReport = generateGeographicOptimizationReport(results);
    console.log('âœ… Geographic optimization analysis complete');

    return results;

  }} catch (error) {{
    console.error('âŒ Geographic optimization failed:', error);
    throw error;
  }}
}}

/**
 * Analyze radius performance for optimal targeting
 */
function analyzeRadiusPerformance() {{
  const radiusOptimizations = [];

  for (const store of STORE_DATA) {{
    console.log(`Analyzing radius performance for ${{store.name}}`);

    // Define radius segments to analyze
    const radiusSegments = [
      {{ start: 0, end: 5 }},
      {{ start: 5, end: 10 }},
      {{ start: 10, end: 15 }},
      {{ start: 15, end: 25 }},
      {{ start: 25, end: 50 }},
    ];

    const segmentPerformance = [];

    for (const segment of radiusSegments) {{
      // Get performance data for this radius segment
      const performanceData = getRadiusSegmentPerformance(
        store.latitude,
        store.longitude,
        segment.start,
        segment.end
      );

      if (performanceData.impressions >= CONFIG.MIN_IMPRESSIONS) {{
        const efficiency = calculateRadiusEfficiency(performanceData);
        const bidAdjustment = calculateOptimalBidAdjustment(efficiency, segment);

        segmentPerformance.push({{
          radiusStart: segment.start,
          radiusEnd: segment.end,
          ...performanceData,
          efficiencyScore: efficiency,
          recommendedBidAdjustment: bidAdjustment,
        }});
      }}
    }}

    // Find optimal radius configuration
    const optimalRadius = findOptimalRadius(segmentPerformance);

    radiusOptimizations.push({{
      storeId: store.storeId,
      storeName: store.name,
      currentRadius: store.radiusMiles,
      recommendedRadius: optimalRadius.radius,
      segmentPerformance: segmentPerformance,
      expectedImpact: optimalRadius.expectedImpact,
      confidenceScore: optimalRadius.confidence,
    }});
  }}

  return radiusOptimizations;
}}

/**
 * Generate geographic bid adjustments based on performance
 */
function generateGeographicBidAdjustments() {{
  const bidAdjustments = [];

  // Get location performance report
  const locationReport = AdsApp.report(
    'SELECT CountryCriteriaId, RegionCriteriaId, CityCriteriaId, LocationType, ' +
    'Impressions, Clicks, Conversions, Cost, ConversionRate, AveragePosition, ' +
    'CampaignName, AdGroupName ' +
    'FROM GEO_PERFORMANCE_REPORT ' +
    'WHERE Impressions > ' + CONFIG.MIN_IMPRESSIONS + ' ' +
    'DURING LAST_' + CONFIG.LOOKBACK_DAYS + '_DAYS'
  );

  const locationPerformance = {{}};
  const locationIterator = locationReport.rows();

  while (locationIterator.hasNext()) {{
    const row = locationIterator.next();
    const locationId = row['CityCriteriaId'] || row['RegionCriteriaId'];
    const locationName = getLocationName(locationId);

    if (!locationPerformance[locationId]) {{
      locationPerformance[locationId] = {{
        locationName: locationName,
        totalImpressions: 0,
        totalClicks: 0,
        totalConversions: 0,
        totalCost: 0,
        campaigns: new Set(),
      }};
    }}

    const perf = locationPerformance[locationId];
    perf.totalImpressions += parseInt(row['Impressions']);
    perf.totalClicks += parseInt(row['Clicks']);
    perf.totalConversions += parseInt(row['Conversions']);
    perf.totalCost += parseFloat(row['Cost']);
    perf.campaigns.add(row['CampaignName']);
  }}

  // Calculate bid adjustments for each location
  for (const [locationId, perf] of Object.entries(locationPerformance)) {{
    const metrics = calculateLocationMetrics(perf);
    const benchmarkMetrics = calculateBenchmarkMetrics(locationPerformance);

    const bidAdjustment = calculateLocationBidAdjustment(metrics, benchmarkMetrics);

    if (Math.abs(bidAdjustment) >= CONFIG.MIN_BID_ADJUSTMENT) {{
      // Find nearest store for context
      const nearestStore = findNearestStore(locationId);

      bidAdjustments.push({{
        locationId: locationId,
        locationName: perf.locationName,
        currentBidAdjustment: getCurrentBidAdjustment(locationId),
        recommendedBidAdjustment: bidAdjustment,
        performance: metrics,
        benchmark: benchmarkMetrics,
        nearestStore: nearestStore ? nearestStore.name : null,
        reasoning: generateBidAdjustmentReasoning(metrics, benchmarkMetrics, bidAdjustment),
        expectedImpact: calculateBidAdjustmentImpact(metrics, bidAdjustment),
        priority: calculateAdjustmentPriority(metrics, bidAdjustment),
      }});
    }}
  }}

  // Sort by priority and impact
  return bidAdjustments.sort((a, b) => {{
    const priorityOrder = {{ 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 }};
    return priorityOrder[b.priority] - priorityOrder[a.priority];
  }});
}}

/**
 * Identify underperforming locations for exclusion
 */
function identifyLocationExclusions() {{
  const exclusions = [];

  // Analyze location performance with stricter criteria
  const locationReport = AdsApp.report(
    'SELECT CountryCriteriaId, RegionCriteriaId, CityCriteriaId, LocationType, ' +
    'Impressions, Clicks, Conversions, Cost, ConversionRate ' +
    'FROM GEO_PERFORMANCE_REPORT ' +
    'WHERE Impressions > ' + (CONFIG.MIN_IMPRESSIONS / 2) + ' ' +
    'DURING LAST_' + (CONFIG.LOOKBACK_DAYS * 2) + '_DAYS'
  );

  const locationIterator = locationReport.rows();
  const poorPerformers = [];

  while (locationIterator.hasNext()) {{
    const row = locationIterator.next();
    const locationId = row['CityCriteriaId'] || row['RegionCriteriaId'];
    const locationName = getLocationName(locationId);

    const metrics = {{
      locationId: locationId,
      locationName: locationName,
      impressions: parseInt(row['Impressions']),
      clicks: parseInt(row['Clicks']),
      conversions: parseInt(row['Conversions']),
      cost: parseFloat(row['Cost']),
      conversionRate: parseFloat(row['ConversionRate']),
      ctr: (parseInt(row['Clicks']) / parseInt(row['Impressions'])) * 100,
      cpc: parseFloat(row['Cost']) / parseInt(row['Clicks']),
    }};

    // Check exclusion criteria
    const shouldExclude = evaluateExclusionCriteria(metrics);

    if (shouldExclude.exclude) {{
      // Ensure location is not near any store
      const nearestStore = findNearestStore(locationId);
      const distanceToStore = nearestStore ?
        calculateDistance(locationId, nearestStore) : Infinity;

      if (distanceToStore > CONFIG.MIN_STORE_DISTANCE) {{
        exclusions.push({{
          locationId: locationId,
          locationName: locationName,
          metrics: metrics,
          exclusionReasons: shouldExclude.reasons,
          potentialSavings: shouldExclude.savings,
          nearestStore: nearestStore ? nearestStore.name : null,
          distanceToNearestStore: distanceToStore,
          riskLevel: calculateExclusionRisk(metrics, distanceToStore),
        }});
      }}
    }}
  }}

  return exclusions.sort((a, b) => b.potentialSavings - a.potentialSavings);
}}

/**
 * Comprehensive store performance analysis
 */
function analyzeStorePerformance() {{
  const storeAnalysis = [];

  for (const store of STORE_DATA) {{
    console.log(`Analyzing performance for ${{store.name}}`);

    // Get campaigns associated with this store
    const storeCampaigns = getStoreCampaigns(store);

    if (storeCampaigns.length === 0) {{
      continue;
    }}

    // Analyze performance across multiple dimensions
    const performanceAnalysis = {{
      storeId: store.storeId,
      storeName: store.name,
      location: `${{store.city}}, ${{store.state}}`,

      // Campaign performance
      campaignPerformance: analyzeCampaignPerformance(storeCampaigns),

      // Keyword performance
      keywordPerformance: analyzeKeywordPerformance(storeCampaigns),

      // Time-based performance
      timeBasedPerformance: analyzeTimeBasedPerformance(storeCampaigns),

      // Demographic performance
      demographicPerformance: analyzeDemographicPerformance(storeCampaigns),

      // Competitive metrics
      competitiveMetrics: analyzeStoreCompetition(store),

      // Growth opportunities
      growthOpportunities: identifyGrowthOpportunities(store, storeCampaigns),

      // Performance score and ranking
      overallScore: calculateStorePerformanceScore(store, storeCampaigns),
      industryRanking: calculateIndustryRanking(store),
    }};

    storeAnalysis.push(performanceAnalysis);
  }}

  return storeAnalysis.sort((a, b) => b.overallScore - a.overallScore);
}}

/**
 * Analyze competitive landscape for local optimization
 */
function analyzeCompetitiveLandscape() {{
  const competitiveInsights = [];

  for (const store of STORE_DATA) {{
    // Analyze auction insights data for store campaigns
    const auctionInsights = getAuctionInsightsData(store);

    if (auctionInsights.length === 0) {{
      continue;
    }}

    const competitiveAnalysis = {{
      storeId: store.storeId,
      storeName: store.name,

      // Market share analysis
      marketShare: calculateMarketShare(auctionInsights),

      // Competitor identification
      topCompetitors: identifyTopCompetitors(auctionInsights),

      // Competitive positioning
      competitivePosition: analyzeCompetitivePosition(auctionInsights),

      // Opportunity analysis
      competitiveOpportunities: identifyCompetitiveOpportunities(auctionInsights),

      // Threat assessment
      competitiveThreats: assessCompetitiveThreats(auctionInsights),

      // Strategic recommendations
      strategicRecommendations: generateCompetitiveStrategy(store, auctionInsights),
    }};

    competitiveInsights.push(competitiveAnalysis);
  }}

  return competitiveInsights;
}}

/**
 * Analyze seasonal patterns and temporal optimization
 */
function analyzeSeasonalPatterns() {{
  const seasonalAdjustments = [];

  // Get historical performance data
  const performanceReport = AdsApp.report(
    'SELECT Date, DayOfWeek, HourOfDay, Impressions, Clicks, Conversions, Cost, ' +
    'CampaignName, LocationCriteriaId ' +
    'FROM GEO_PERFORMANCE_REPORT ' +
    'WHERE Impressions > 0 ' +
    'DURING LAST_90_DAYS'
  );

  const temporalData = {{}};
  const performanceIterator = performanceReport.rows();

  while (performanceIterator.hasNext()) {{
    const row = performanceIterator.next();
    const date = new Date(row['Date']);
    const dayOfWeek = parseInt(row['DayOfWeek']);
    const hour = parseInt(row['HourOfDay']);
    const locationId = row['LocationCriteriaId'];

    // Group data by location and temporal dimensions
    if (!temporalData[locationId]) {{
      temporalData[locationId] = {{
        hourly: Array(24).fill(null).map(() => ({{ impressions: 0, clicks: 0, conversions: 0, cost: 0 }})),
        daily: Array(7).fill(null).map(() => ({{ impressions: 0, clicks: 0, conversions: 0, cost: 0 }})),
        weekly: {{}},
      }};
    }}

    const data = temporalData[locationId];
    const impressions = parseInt(row['Impressions']);
    const clicks = parseInt(row['Clicks']);
    const conversions = parseInt(row['Conversions']);
    const cost = parseFloat(row['Cost']);

    // Aggregate hourly data
    data.hourly[hour].impressions += impressions;
    data.hourly[hour].clicks += clicks;
    data.hourly[hour].conversions += conversions;
    data.hourly[hour].cost += cost;

    // Aggregate daily data
    data.daily[dayOfWeek].impressions += impressions;
    data.daily[dayOfWeek].clicks += clicks;
    data.daily[dayOfWeek].conversions += conversions;
    data.daily[dayOfWeek].cost += cost;
  }}

  // Analyze patterns and generate recommendations
  for (const [locationId, data] of Object.entries(temporalData)) {{
    const nearestStore = findNearestStore(locationId);

    const seasonalAnalysis = {{
      locationId: locationId,
      locationName: getLocationName(locationId),
      nearestStore: nearestStore ? nearestStore.name : null,

      // Hourly patterns
      optimalHours: identifyOptimalHours(data.hourly),
      underperformingHours: identifyUnderperformingHours(data.hourly),

      // Daily patterns
      optimalDays: identifyOptimalDays(data.daily),
      underperformingDays: identifyUnderperformingDays(data.daily),

      // Recommendations
      daypartAdjustments: generateDaypartAdjustments(data),
      scheduleOptimization: generateScheduleOptimization(data),

      // Expected impact
      expectedImpact: calculateSeasonalImpact(data),
    }};

    seasonalAdjustments.push(seasonalAnalysis);
  }}

  return seasonalAdjustments;
}}

/**
 * Analyze cross-location coordination and prevent cannibalization
 */
function analyzeCrossLocationCoordination() {{
  const crossLocationAnalysis = [];

  // Group campaigns by location/store
  const campaignsByLocation = {{}};

  const campaigns = AdsApp.campaigns()
    .withCondition('Status = ENABLED')
    .get();

  while (campaigns.hasNext()) {{
    const campaign = campaigns.next();
    const campaignName = campaign.getName();
    const location = extractLocationFromCampaignName(campaignName);

    if (location) {{
      if (!campaignsByLocation[location]) {{
        campaignsByLocation[location] = [];
      }}
      campaignsByLocation[location].push(campaign);
    }}
  }}

  // Analyze potential conflicts between locations
  const locations = Object.keys(campaignsByLocation);

  for (let i = 0; i < locations.length; i++) {{
    for (let j = i + 1; j < locations.length; j++) {{
      const location1 = locations[i];
      const location2 = locations[j];

      const conflictAnalysis = analyzeLocationConflict(
        location1, campaignsByLocation[location1],
        location2, campaignsByLocation[location2]
      );

      if (conflictAnalysis.hasConflicts) {{
        crossLocationAnalysis.push({{
          location1: location1,
          location2: location2,
          conflictType: conflictAnalysis.conflictType,
          severity: conflictAnalysis.severity,
          affectedCampaigns: conflictAnalysis.affectedCampaigns,
          overlapMetrics: conflictAnalysis.overlapMetrics,
          cannibalizationRisk: conflictAnalysis.cannibalizationRisk,
          recommendations: conflictAnalysis.recommendations,
          expectedImpact: conflictAnalysis.expectedImpact,
        }});
      }}
    }}
  }}

  return crossLocationAnalysis.sort((a, b) => {{
    const severityOrder = {{ 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 }};
    return severityOrder[b.severity] - severityOrder[a.severity];
  }});
}}

/**
 * Generate comprehensive geographic optimization report
 */
function generateGeographicOptimizationReport(results) {{
  const summary = {{
    totalStoresAnalyzed: STORE_DATA.length,
    radiusOptimizations: results.radiusOptimizations.length,
    bidAdjustments: results.bidAdjustments.length,
    locationExclusions: results.locationExclusions.length,
    seasonalAdjustments: results.seasonalAdjustments.length,
    crossLocationConflicts: results.crossLocationAnalysis.length,

    // Impact estimates
    estimatedImprovements: {{
      costEfficiencyGain: calculateCostEfficiencyGain(results),
      conversionRateImprovement: calculateConversionImpact(results),
      storeVisitIncrease: calculateStoreVisitImpact(results),
      marketShareGrowth: calculateMarketShareGrowth(results),
    }},

    // Priority actions
    highPriorityActions: identifyHighPriorityActions(results),
    quickWins: identifyQuickWins(results),
    longTermOpportunities: identifyLongTermOpportunities(results),
  }};

  console.log('ðŸ“Š Geographic Optimization Summary:');
  console.log(`- Stores Analyzed: ${{summary.totalStoresAnalyzed}}`);
  console.log(`- Radius Optimizations: ${{summary.radiusOptimizations}}`);
  console.log(`- Bid Adjustments: ${{summary.bidAdjustments}}`);
  console.log(`- Location Exclusions: ${{summary.locationExclusions}}`);
  console.log(`- Seasonal Adjustments: ${{summary.seasonalAdjustments}}`);
  console.log(`- Cross-Location Conflicts: ${{summary.crossLocationConflicts}}`);

  return summary;
}}

// Additional utility functions would be implemented here...
"""

    def _generate_store_data_js(self) -> str:
        """Generate JavaScript representation of enhanced store data."""
        stores_data = []
        for store in self.config.parameters.get("store_locations", []):
            stores_data.append(
                f"""  {{
    storeId: '{store.get("store_id", "")}',
    name: '{store.get("name", "")}',
    city: '{store.get("city", "")}',
    state: '{store.get("state", "")}',
    latitude: {store.get("latitude", 0)},
    longitude: {store.get("longitude", 0)},
    radiusMiles: {store.get("radius_miles", 25)},
    landingPage: '{store.get("landing_page", "")}',
    storeType: '{store.get("store_type", "retail")}',
    marketTier: '{store.get("market_tier", "primary")}',
    competitorDensity: '{store.get("competitor_density", "medium")}',
    seasonalityIndex: {store.get("seasonality_index", 1.0)},
  }}"""
            )

        return f"""
// Enhanced Store Data Configuration
const STORE_DATA = [
{",".join(stores_data)}
];"""

    def _generate_optimization_config_js(self) -> str:
        """Generate JavaScript configuration for optimization parameters."""
        return f"""
// Geographic Optimization Configuration
const CONFIG = {{
  LOOKBACK_DAYS: {self.config.parameters.get("lookback_days", 30)},
  MIN_IMPRESSIONS: {self.config.parameters.get("min_impressions", 100)},
  MIN_BID_ADJUSTMENT: {self.config.parameters.get("min_bid_adjustment", 5)},
  MAX_BID_ADJUSTMENT: {self.config.parameters.get("max_bid_adjustment", 50)},
  MIN_STORE_DISTANCE: {self.config.parameters.get("min_store_distance_miles", 10)},
  EFFICIENCY_THRESHOLD: {self.config.parameters.get("efficiency_threshold", 0.7)},
  EXCLUSION_COST_THRESHOLD: {self.config.parameters.get("exclusion_cost_threshold", 50)},
  SEASONAL_LOOKBACK_DAYS: {self.config.parameters.get("seasonal_lookback_days", 90)},
}};"""

    def process_results(self, results: Dict[str, Any]) -> ScriptResult:
        """Process geographic optimization results."""
        try:
            radius_optimizations = results.get("radiusOptimizations", [])
            bid_adjustments = results.get("bidAdjustments", [])
            location_exclusions = results.get("locationExclusions", [])
            store_analysis = results.get("storePerformanceAnalysis", [])
            competitive_insights = results.get("competitiveInsights", [])
            seasonal_adjustments = results.get("seasonalAdjustments", [])
            cross_location_analysis = results.get("crossLocationAnalysis", [])

            # Calculate total optimizations
            total_optimizations = (
                len(radius_optimizations)
                + len(bid_adjustments)
                + len(location_exclusions)
                + len(seasonal_adjustments)
            )

            # Generate warnings for critical issues
            warnings = []

            # Check for critical cross-location conflicts
            critical_conflicts = [
                c for c in cross_location_analysis if c.get("severity") == "critical"
            ]
            if critical_conflicts:
                warnings.append(
                    f"Found {len(critical_conflicts)} critical cross-location conflicts"
                )

            # Check for high-cost locations
            high_cost_exclusions = [
                e for e in location_exclusions if e.get("potentialSavings", 0) > 500
            ]
            if high_cost_exclusions:
                warnings.append(
                    f"{len(high_cost_exclusions)} locations with significant cost savings potential"
                )

            # Check for underperforming stores
            underperforming_stores = [
                s for s in store_analysis if s.get("overallScore", 1.0) < 0.6
            ]
            if underperforming_stores:
                warnings.append(
                    f"{len(underperforming_stores)} stores showing poor performance metrics"
                )

            return ScriptResult(
                status=ScriptStatus.COMPLETED.value,
                execution_time=0.0,  # Will be set by executor
                rows_processed=len(store_analysis) + len(bid_adjustments),
                changes_made=total_optimizations,
                errors=[],
                warnings=warnings,
                details={
                    "geographic_optimization": {
                        "stores_analyzed": len(store_analysis),
                        "radius_optimizations": len(radius_optimizations),
                        "optimal_radius_changes": len(
                            [
                                r
                                for r in radius_optimizations
                                if r.get("currentRadius") != r.get("recommendedRadius")
                            ]
                        ),
                    },
                    "bid_optimization": {
                        "total_bid_adjustments": len(bid_adjustments),
                        "critical_adjustments": len(
                            [
                                b
                                for b in bid_adjustments
                                if b.get("priority") == "critical"
                            ]
                        ),
                        "high_impact_adjustments": len(
                            [
                                b
                                for b in bid_adjustments
                                if abs(b.get("recommendedBidAdjustment", 0)) > 20
                            ]
                        ),
                    },
                    "location_management": {
                        "exclusion_candidates": len(location_exclusions),
                        "total_potential_savings": sum(
                            e.get("potentialSavings", 0) for e in location_exclusions
                        ),
                    },
                    "competitive_analysis": {
                        "stores_with_competitive_data": len(competitive_insights),
                        "market_opportunities": sum(
                            len(c.get("competitiveOpportunities", []))
                            for c in competitive_insights
                        ),
                    },
                    "temporal_optimization": {
                        "locations_with_seasonal_data": len(seasonal_adjustments),
                        "daypart_optimization_opportunities": sum(
                            len(s.get("daypartAdjustments", []))
                            for s in seasonal_adjustments
                        ),
                    },
                    "cross_location_analysis": {
                        "potential_conflicts": len(cross_location_analysis),
                        "cannibalization_risks": len(
                            [
                                c
                                for c in cross_location_analysis
                                if c.get("cannibalizationRisk", "low")
                                in ["high", "critical"]
                            ]
                        ),
                    },
                },
            )

        except Exception as e:
            logger.error(f"Error processing geographic optimization results: {str(e)}")
            return ScriptResult(
                status=ScriptStatus.FAILED.value,
                execution_time=0.0,
                rows_processed=0,
                changes_made=0,
                errors=[f"Results processing error: {str(e)}"],
                warnings=[],
                details={},
            )

    def get_required_parameters(self) -> List[str]:
        """Get required parameters for geographic optimization."""
        return [
            "store_locations",  # List of store location data
            "lookback_days",  # Days to analyze
            "min_impressions",  # Minimum impressions threshold
        ]

    def analyze_radius_performance(
        self, store: StoreLocation, radius_segments: List[Tuple[int, int]]
    ) -> List[RadiusPerformanceSegment]:
        """Analyze performance by radius segments for a store."""
        segments = []

        for radius_start, radius_end in radius_segments:
            # This would integrate with Google Ads API to get actual performance data
            # For now, create placeholder segments
            segment = RadiusPerformanceSegment(
                radius_start=radius_start,
                radius_end=radius_end,
                impressions=1000 * (radius_end - radius_start),  # Placeholder
                clicks=50 * (radius_end - radius_start),  # Placeholder
                conversions=5 * (radius_end - radius_start),  # Placeholder
                cost=125.0 * (radius_end - radius_start),  # Placeholder
                store_visits=8 * (radius_end - radius_start),  # Placeholder
                efficiency_score=self._calculate_efficiency_score(
                    radius_start, radius_end
                ),
                recommended_bid_adjustment=self._calculate_radius_bid_adjustment(
                    radius_start, radius_end
                ),
            )
            segments.append(segment)

        return segments

    def _calculate_efficiency_score(self, radius_start: int, radius_end: int) -> float:
        """Calculate efficiency score for a radius segment."""
        # Closer radius segments typically perform better
        avg_radius = (radius_start + radius_end) / 2
        if avg_radius <= 5:
            return 0.9
        elif avg_radius <= 10:
            return 0.8
        elif avg_radius <= 15:
            return 0.7
        elif avg_radius <= 25:
            return 0.6
        else:
            return 0.4

    def _calculate_radius_bid_adjustment(
        self, radius_start: int, radius_end: int
    ) -> float:
        """Calculate recommended bid adjustment for radius segment."""
        avg_radius = (radius_start + radius_end) / 2

        # Higher bids for closer radius (higher intent)
        if avg_radius <= 5:
            return 20.0  # +20% for very close
        elif avg_radius <= 10:
            return 10.0  # +10% for close
        elif avg_radius <= 15:
            return 0.0  # No adjustment for medium
        elif avg_radius <= 25:
            return -10.0  # -10% for far
        else:
            return -20.0  # -20% for very far

    def analyze_store_performance(
        self, store: StoreLocation
    ) -> GeographicPerformanceMetric:
        """Analyze performance metrics for a specific store."""
        # This would integrate with Google Ads API to get actual performance data
        # For now, create placeholder performance data
        return GeographicPerformanceMetric(
            location=f"{store.city}, {store.state}",
            radius_miles=store.radius_miles,
            impressions=5000,  # Placeholder
            clicks=250,  # Placeholder
            conversions=25,  # Placeholder
            cost=625.0,  # Placeholder
            store_visits=35,  # Placeholder
            ctr=5.0,  # Placeholder
            cpc=2.50,  # Placeholder
            conversion_rate=10.0,  # Placeholder
            efficiency_score=0.75,  # Placeholder
        )

    def generate_geographic_recommendations(
        self, store_locations: List[StoreLocation]
    ) -> List[GeographicRecommendation]:
        """Generate comprehensive geographic optimization recommendations."""
        recommendations = []

        for store in store_locations:
            # Analyze current performance
            current_performance = self.analyze_store_performance(store)

            # Generate radius optimization recommendation
            if current_performance.efficiency_score < 0.7:
                recommendations.append(
                    GeographicRecommendation(
                        action_type=GeographicActionType.RADIUS_OPTIMIZATION,
                        priority=OptimizationPriority.HIGH,
                        location_identifier=store.store_id,
                        current_performance=current_performance,
                        recommended_change={
                            "current_radius": store.radius_miles,
                            "recommended_radius": max(15, store.radius_miles - 10),
                        },
                        expected_impact={
                            "cost_reduction": 15.0,
                            "efficiency_improvement": 25.0,
                        },
                        confidence_score=0.85,
                        reasoning="Current radius shows poor efficiency. Reducing radius will focus on higher-intent local traffic.",
                    )
                )

        return recommendations


def create_geographic_optimization_config(
    store_locations: List[Dict[str, Any]],
    lookback_days: int = 30,
    min_impressions: int = 100,
) -> ScriptConfig:
    """Create configuration for geographic optimization script."""
    return ScriptConfig(
        name="Geographic Optimization and Store-Level Performance Enhancement",
        type=ScriptType.MASTER_NEGATIVE_LIST,  # Using existing enum for compatibility
        description="Advanced geographic targeting optimization and store-level performance analysis",
        parameters={
            "store_locations": store_locations,
            "lookback_days": lookback_days,
            "min_impressions": min_impressions,
            "min_bid_adjustment": 5,
            "max_bid_adjustment": 50,
            "min_store_distance_miles": 10,
            "efficiency_threshold": 0.7,
            "exclusion_cost_threshold": 50,
            "seasonal_lookback_days": 90,
        },
    )
